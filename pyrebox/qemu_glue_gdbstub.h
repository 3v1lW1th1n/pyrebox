#ifndef QEMU_GLUE_GDBSTUB
#define QEMU_GLUE_GDBSTUB

/* GDB breakpoint/watchpoint types */
#define GDB_BREAKPOINT_SW        0
#define GDB_BREAKPOINT_HW        1
#define GDB_WATCHPOINT_WRITE     2
#define GDB_WATCHPOINT_READ      3
#define GDB_WATCHPOINT_ACCESS    4

#ifdef NEED_CPU_H
#include "cpu.h"
#endif

typedef int (*gdb_reg_cb)(CPUArchState *env, uint8_t *buf, int reg);

// Initialize a gdb session on a given port.
int pyrebox_gdbserver_start(unsigned int port);

// Function that must be called when a debugged process
// exits. It signals the attached GDB (if any), closing
// the session.
void pyrebox_gdb_exit(CPUArchState *env, int code);

// Send attached GDB a packet to close the debugging
// session.
void pyrebox_gdbserver_cleanup(void);

void gdb_signal_breakpoint(unsigned int thread_index);

/**
 * gdb_has_xml:
 * This is an ugly hack to cope with both new and old gdb.
 * If gdb sends qXfer:features:read then assume we're talking to a newish
 * gdb that understands target descriptions.
 */
//extern bool pyrebox_gdb_has_xml;

/* in gdbstub-xml.c, generated by scripts/feature_to_c.sh */
extern const char *const xml_builtin[][2];



#endif
